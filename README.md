# How to learn modern Rust
A guide to the adventurer.

## Learn Rust deeply one step after the other

Rust is an incredible powerful programming language. It is fast, compiled, without a runtime and it brings new concepts of safety to programming. <br>
It is the most beloved language for five years in a row in Stack Overflow users pool. <br> 
To learn Rust go through the following content **in the listed order**, the majority of the content is free. <br>

1. **Why Developers Love Rust** <br>
   [https://ibraheem.ca/posts/why-devs-love-rust](https://ibraheem.ca/posts/why-devs-love-rust)

2. **Video - Rust Crash Course - Rustlang** <br>
   [https://www.youtube.com/watch?v=zF34dRivLOw](https://www.youtube.com/watch?v=zF34dRivLOw)

3. **Video - Introduction to Rust Part 1** <br>
   [https://www.youtube.com/watch?v=WnWGO-tLtLA](https://www.youtube.com/watch?v=WnWGO-tLtLA)

4. **Video - Introduction to Rust Part 2** <br>
   [https://www.youtube.com/watch?v=lLWchWTUFOQ](https://www.youtube.com/watch?v=lLWchWTUFOQ)

5. **A half-hour to learn Rust** <br>
   [https://fasterthanli.me/articles/a-half-hour-to-learn-rust](https://fasterthanli.me/articles/a-half-hour-to-learn-rust)

6. **The Rust Programming Language Book** <br>
   by Steve Klabnik and Carol Nichols, with contributions from the Rust Community <br>
   [https://doc.rust-lang.org/stable/book/](https://doc.rust-lang.org/stable/book/)

7. **Rust Language Cheat Sheet** <br>
   [https://cheats.rs/](https://cheats.rs/)

8. **Rustlings** <br>
   Small exercises to get you used to reading and writing Rust code. <br>
   [https://github.com/rust-lang/rustlings](https://github.com/rust-lang/rustlings)

9. **Videos - Microsoft Beginner's Series to Rust** <br>
   [https://www.youtube.com/playlist?list=PLlrxD0HtieHjbTjrchBwOVks_sr8EVW1x](https://www.youtube.com/playlist?list=PLlrxD0HtieHjbTjrchBwOVks_sr8EVW1x) <br>
   GitHub Code <br>
   [https://github.com/microsoft/beginners-series-rust](https://github.com/microsoft/beginners-series-rust)

10. **Videos - Intro to Rustlang - Tensor Programming** <br>
    [https://www.youtube.com/watch?v=EYqceb2AnkU&list=PLJbE2Yu2zumDF6BX6_RdPisRVHgzV02NW](https://www.youtube.com/watch?v=EYqceb2AnkU&list=PLJbE2Yu2zumDF6BX6_RdPisRVHgzV02NW)

11. **Videos - Rustlang Project - Tensor Programming** <br>
    [https://www.youtube.com/watch?v=-Jp7sabBCp4&list=PLJbE2Yu2zumDD5vy2BuSHvFZU0a6RDmgb](https://www.youtube.com/watch?v=-Jp7sabBCp4&list=PLJbE2Yu2zumDD5vy2BuSHvFZU0a6RDmgb)

12. **Standard collections - std info and how to choose the correct collection** <br>
    [https://doc.rust-lang.org/std/collections/index.html](https://doc.rust-lang.org/std/collections/index.html)

13. **Video - Unsafe & FFI in Rust** <br>
    [https://www.youtube.com/watch?v=LFFbTeU25pE](https://www.youtube.com/watch?v=LFFbTeU25pE)

14. **Rust by Example Book** <br>
    [https://doc.rust-lang.org/rust-by-example/](https://doc.rust-lang.org/rust-by-example/)

15. **Study carefully the methods of ``` Option<T> ``` in the documentation, they are used in all Rust programs** <br>
    [https://doc.rust-lang.org/beta/std/option/index.html](https://doc.rust-lang.org/beta/std/option/index.html)

16. **Study carefully the methods of ``` Result<T, E> ``` in the documentation, they are used in all Rust programs** <br>
    [https://doc.rust-lang.org/beta/std/result/index.html](https://doc.rust-lang.org/beta/std/result/index.html)

17. **Command Line Applications in Rust - Book** <br>
    [https://rust-cli.github.io/book/in-depth/docs.html](https://rust-cli.github.io/book/in-depth/docs.html)

18. **The Rust Standard Library documentation** <br>
    [https://doc.rust-lang.org/std/](https://doc.rust-lang.org/std/)

19. **Learn Rust With Entirely Too Many Linked Lists - Book** <br>
    [https://rust-unofficial.github.io/too-many-lists/](https://rust-unofficial.github.io/too-many-lists/)

20. **Rust Design Patterns - Book** <br>
    [https://rust-unofficial.github.io/patterns/](https://rust-unofficial.github.io/patterns/)

21. **The Rust Cookbook - Book** <br>
    [https://rust-lang-nursery.github.io/rust-cookbook/](https://rust-lang-nursery.github.io/rust-cookbook/)

22. **The Cargo Book** <br>
    [https://doc.rust-lang.org/cargo/index.html](https://doc.rust-lang.org/cargo/index.html)

23. **Guide trough of the Advent of Code 2020** <br>
    [https://fasterthanli.me/series/advent-of-code-2020](https://fasterthanli.me/series/advent-of-code-2020)

24. **Rust API Guidelines Book** <br>
    [https://rust-lang.github.io/api-guidelines/about.html](https://rust-lang.github.io/api-guidelines/about.html)

25. **The Rust Reference Book** <br>
    [https://doc.rust-lang.org/stable/reference/](https://doc.rust-lang.org/stable/reference/)

26. **The Rustonomicon - The Dark Arts of Unsafe Rust - Book** <br>
    [https://doc.rust-lang.org/nomicon/](https://doc.rust-lang.org/nomicon/)

27. **The Little Book of Rust Macros - Book** <br>
    [https://veykril.github.io/tlborm/introduction.html](https://veykril.github.io/tlborm/introduction.html)

28. **Writing Interpreters in Rust: a Guide - Book** <br>
    [https://rust-hosted-langs.github.io/book/introduction.html](https://rust-hosted-langs.github.io/book/introduction.html)

29. **Video - Cheaply writing a fast interpreter - Neil Mitchell** <br>
    [https://www.youtube.com/watch?v=V8dnIw3amLA](https://www.youtube.com/watch?v=V8dnIw3amLA) <br>
    github <br>
    [https://github.com/ndmitchell/interpret](https://github.com/ndmitchell/interpret)

30. **Make A Language** <br>
    A series about making a programming language called **Eldiro** using the Rust programming language. <br>
    [https://arzg.github.io/lang/](https://arzg.github.io/lang/)

31. **Rust and WebAssembly - Book** <br>
    [https://rustwasm.github.io/docs/book/](https://rustwasm.github.io/docs/book/)

32. **Engineering Rust Web Applications - Book** <br>
    [https://erwabook.com/](https://erwabook.com/)

33. **Programming Rust: Fast, Safe Systems Development 2nd Ed** <br>
    by Jim Blandy, Jason Orendorff

34. **Rust for Rustaceans: Idiomatic Programming for Experienced Developers** <br>
    by Jon Gjengset

35. **Practical System Programming for Rust Developers**: Build fast and secure software for Linux/Unix systems with the help of practical examples <br>
    by Prabhu Eshwarla

36. **Hands-On Concurrency with Rust**: Confidently build memory-safe, parallel, and efficient software in Rust <br>
    by Brian L. Troutwine 

37. **GDB: The GNU Project Debugger** <br>
    [https://www.gnu.org/software/gdb/documentation/](https://www.gnu.org/software/gdb/documentation/)

38. **The LLDB Debugger** <br>
    [https://lldb.llvm.org/](https://lldb.llvm.org/)

39. **Valgrind User Manual** <br>
    [https://valgrind.org/docs/manual/manual.html](https://valgrind.org/docs/manual/manual.html)

40. **The perf Linux profiler - Examples of use** <br>
    [https://www.brendangregg.com/perf.html](https://www.brendangregg.com/perf.html)

41. **QuickCheck - QuickCheck is a way to do property based testing using randomly generated input.** <br>
    [https://github.com/BurntSushi/quickcheck](https://github.com/BurntSushi/quickcheck)

42. **American Fuzzy Lop - A good fuzzer** <br>
    [https://lcamtuf.coredump.cx/afl/](https://lcamtuf.coredump.cx/afl/)

43. **Criterion rs - Statistics-driven Microbenchmarking in Rust** <br>
    [https://github.com/bheisler/criterion.rs](https://github.com/bheisler/criterion.rs)

44. **The Complete Rust Programming Reference Guide**: Design, develop, and deploy effective software systems using the advanced constructs of Rust <br>
	 by Rahul Sharma, Vesa Kaihlavirta 

45. **Creative Projects for Rust Programmers**: Build exciting projects on domains such as web apps, WebAssembly, games, and parsing <br>
    by Carlo Milanesi

46. **Rust High Performance**: Learn to skyrocket the performance of your Rust applications <br>
    by Iban Eguia Moraza 

47. **Writing an OS in Rust Philipp Oppermann's blog** <br>
    [https://os.phil-opp.com/](https://os.phil-opp.com/)

48. **The Rust Unstable Book** <br>
    [https://doc.rust-lang.org/beta/unstable-book/](https://doc.rust-lang.org/beta/unstable-book/)


## How Rust maps to memory and lifetimes annotations in Rust

1. **Video - Visualizing memory layout of Rust's data types - Sreekanth** <br>
   **Incredible video!** <br>
   [https://www.youtube.com/watch?v=rDoqT-a6UFg](https://www.youtube.com/watch?v=rDoqT-a6UFg)

2. **Video - Understanding Rust Lifetimes - Ryan Levick** <br>
   [https://www.youtube.com/watch?v=MSi3E5Z8oRw](https://www.youtube.com/watch?v=MSi3E5Z8oRw)

3. **Video - Crust of Rust: Lifetime Annotations - Jon Gjengset** <br>
   [https://www.youtube.com/watch?v=rAl-9HwD858](https://www.youtube.com/watch?v=rAl-9HwD858)


## Background in systems programming

1. **How to lean modern Linux** <br>
   [https://github.com/joaocarvalhoopen/How_to_learn_modern_Linux](https://github.com/joaocarvalhoopen/How_to_learn_modern_Linux)

2. **Safe Systems Programming in Rust** <br>
   By Ralf Jung, Jacques-Henri Jourdan, Robbert Krebbers, Derek Dreyer <br>
   [https://cacm.acm.org/magazines/2021/4/251364-safe-systems-programming-in-rust/fulltext](https://cacm.acm.org/magazines/2021/4/251364-safe-systems-programming-in-rust/fulltext)

3. **The Linux Command Line, 2nd Edition: A Complete Introduction Illustrated Edition** <br>
   by William Shotts

4. **How Linux Works, 3rd Edition: What Every Superuser Should Know 3rd Edition** <br>
   by Brian Ward

5. **Operating Systems: Three Easy Pieces** <br>
   Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau <br>
   [http://pages.cs.wisc.edu/~remzi/OSTEP/](http://pages.cs.wisc.edu/~remzi/OSTEP/)  

6. **The Linux Programming Interface: A Linux and UNIX System Programming Handbook** <br>
   by Michael Kerrisk

7. **Linux Device Drivers, 3th Edition** <br>
   [https://lwn.net/Kernel/LDD3/](https://lwn.net/Kernel/LDD3/)

8. **Linux Driver Development for Embedded Processors - 2th Edition**: Learn to develop Linux embedded drivers with kernel 4.9 LTS <br>
   by Alberto Liberal de los Ríos

9. **Computer Systems: A Programmer's Perspective 3rd Edition** <br>
   by Randal Bryant, David O'Hallaron

10. **Computer Networking: A Top-Down Approach** <br> 
   by James Kurose

11. **The Illustrated Network: How TCP/IP Works in a Modern Network 2nd Edition** <br>
   by Walter Goralski

12. **Crafting Interpreters** <br>
	by Robert Nystrom <br>
	The book license is Creative Commons. <br>
	[https://craftinginterpreters.com/](https://craftinginterpreters.com/)

13. **Writing An Interpreter In Go** <br> 
    by Thorsten Ball

14. **Writing A Compiler In Go** <br>
    by Thorsten Ball

15. **Compilers: Principles, Techniques, and Tools** <br>
    by Alfred Aho, Monica Lam, Ravi Sethi

16. **C Programming: A Modern Approach, 2nd Edition** <br>
    by K. N. King

17. **Extreme C: Taking you to the limit in Concurrency, OOP, and the most advanced capabilities of C** <br>
    by Kamran Amini

18. **C++ Crash Course: A Fast-Paced Introduction** <br>
    by Josh Lospinoso


## Python extended with Rust and running a Python interpreter inside Rust  

1. **PyO3 - GitHub** <br>
   [https://github.com/PyO3/pyo3](https://github.com/PyO3/pyo3)

2. **The PyO3 user guide - Book** <br>
   [https://pyo3.rs/master/](https://pyo3.rs/master/)

3. **Python Extensions in Pure Rust with PyO3** <br>
   [https://depth-first.com/articles/2020/08/10/python-extensions-in-pure-rust-with-pyo3/](https://depth-first.com/articles/2020/08/10/python-extensions-in-pure-rust-with-pyo3/)   

4. **RustPython - A Python-3 interpreter written in Rust** <br>
   [https://github.com/RustPython/RustPython](https://github.com/RustPython/RustPython)


## Rust with inline Python

In a program made in Rust, ```use a macro to insert inline Python``` and move easily data (variables) between the two. <br>
<br>

``` Python
// Example_1 

use inline_python::python;

fn main() {
    let who = "world";
    let n = 5;
    python! {
        for i in range('n):
            print(i, "Hello", 'who)
        print("Goodbye")
    }
}
```

``` Python
// Example_2 
// Creates the data in Rust and plots the plot with inline Python with the lib matplotlib.

use inline_python::python;

fn main() {
    let data = vec![(4, 3), (2, 8), (3, 1), (4, 0)];
    python! {
        import matplotlib.pyplot as plt
        plt.plot('data)
        plt.show()
    }
}
```

1. Crate **inline-python** <br>
   Inline Python code directly in your Rust code <br>
   [https://crates.io/crates/inline-python](https://crates.io/crates/inline-python)

The inner workings and all the development steps of this project are beautifully explained, in detail, on this sequence of blog posts. <br>

2. **Writing Python inside your Rust code - Part 1** - Mara's Blog <br>
   [https://blog.m-ou.se/writing-python-inside-rust-1/](https://blog.m-ou.se/writing-python-inside-rust-1/)

3. **Writing Python inside your Rust code - Part 1A** - Mara's Blog <br>
   [https://blog.m-ou.se/writing-python-inside-rust-1a/](https://blog.m-ou.se/writing-python-inside-rust-1a/)

4. **Writing Python inside your Rust code - Part 2** - Mara's Blog <br>
   [https://blog.m-ou.se/writing-python-inside-rust-2/](https://blog.m-ou.se/writing-python-inside-rust-2/)

5. **Writing Python inside your Rust code - Part 3** - Mara's Blog <br>
   [https://blog.m-ou.se/writing-python-inside-rust-3/](https://blog.m-ou.se/writing-python-inside-rust-3/)

6. **Writing Python inside your Rust code - Part 4** - Mara's Blog <br>
   [https://blog.m-ou.se/writing-python-inside-rust-4/](https://blog.m-ou.se/writing-python-inside-rust-4/)


## Rust on or for the Raspberry Pi

* There are **two modes** of using Rust with the Raspberry Pi. <br>
  The first one is **installing Rust development tools on the Raspberry Pi** itself, and the second one is **installing on the PC and making cross-compilation** to generate a executable that runs on the Raspberry Pi.


### Developing on the Raspberry Pi and running Rust programs on the Raspberry Pi

1. **How to Get Started With Rust on Raspberry Pi** <br>
   [https://www.muo.com/tag/getting-started-rust-raspberry-pi/](https://www.muo.com/tag/getting-started-rust-raspberry-pi/)


### Developing on the PC and cross-compiling to run Rust programs on the Raspberry Pi

1. **Cross Compiling Rust for the Raspberry Pi** <br>
   It also explains a method to automatically coping the file to the Raspberry Pi after compilation. <br> 
   [https://chacin.dev/blog/cross-compiling-rust-for-the-raspberry-pi/](https://chacin.dev/blog/cross-compiling-rust-for-the-raspberry-pi/)

2. **Cross compiling Rust for Raspberry Pi** <br>
   [https://dev.to/h_ajsf/cross-compiling-rust-for-raspberry-pi-4iai](https://dev.to/h_ajsf/cross-compiling-rust-for-raspberry-pi-4iai)


## Embedded Rust

1. **An Overview of the Embedded Rust Ecosystem** <br>
   [https://www.youtube.com/watch?v=vLYit_HHPaY](https://www.youtube.com/watch?v=vLYit_HHPaY)

2. **Awesome embedded rust - Github** <br>
   Everything you need to know including drivers to connect external devices to the micro-controller. <br>
   [https://github.com/rust-embedded/awesome-embedded-rust](https://github.com/rust-embedded/awesome-embedded-rust)

3. **Discovery Book** <br>
   [https://docs.rust-embedded.org/discovery/](https://docs.rust-embedded.org/discovery/)

4. **The Embedded Rust Book** <br>
   [https://docs.rust-embedded.org/book/](https://docs.rust-embedded.org/book/)

5. **Workbook for Embedded Workshops - Book** <br>
   [https://embedded-trainings.ferrous-systems.com/](https://embedded-trainings.ferrous-systems.com/)

6. **The Embedonomicon Book** <br>
   [https://docs.rust-embedded.org/embedonomicon/](https://docs.rust-embedded.org/embedonomicon/)

7. **The Embedded Working Group Newsletter or Blog** <br>
   [https://rust-embedded.github.io/blog/](https://rust-embedded.github.io/blog/)


## Links

1. **Rust site** <br>
   A language empowering everyone to build reliable and efficient software. <br>
   [https://www.rust-lang.org/](https://www.rust-lang.org/)

2. **Crate.io - The Rust community’s crate registry** <br>
  [https://crates.io/](https://crates.io/)

3. **Rust weekly news letter** <br>
   [https://this-week-in-rust.org/](https://this-week-in-rust.org/)

4. **The Little Book of Rust Books** <br>
   [https://lborb.github.io/book/title-page.html](https://lborb.github.io/book/title-page.html)

5. **Awesome-rust** <br>
   [https://github.com/rust-unofficial/awesome-rust](https://github.com/rust-unofficial/awesome-rust)

6. **Awesome-embedded-rust** <br>
   [https://github.com/rust-embedded/awesome-embedded-rust](https://github.com/rust-embedded/awesome-embedded-rust)

7. **Rust Analyzer - User manual and short cut keys** <br>
   [https://rust-analyzer.github.io/manual.html](https://rust-analyzer.github.io/manual.html)

8. **Jon Gjengset - Rust in depth Youtube channel.** <br> 
   [https://www.youtube.com/c/JonGjengset](https://www.youtube.com/c/JonGjengset)

9. **Tokio** <br>
   Tokio is an asynchronous runtime (**async** and **await**) for the Rust programming language. It provides the building blocks needed for writing network applications. It gives the flexibility to target a wide range of systems, from large servers with dozens of cores to small embedded devices. <br>
   See the tutorials. <br>
   [https://tokio.rs/](https://tokio.rs/)

10. Best **async** and **await** introduction video. <br>
   **Video - Crust of Rust: async e await - Jon Gjengset** <br>
   [https://www.youtube.com/watch?v=ThjvMReOXYM](https://www.youtube.com/watch?v=ThjvMReOXYM)

11. **Video - Creating a Chat Server with async Rust and Tokio – Lily Mara** <br>
    [https://www.youtube.com/watch?v=Iapc-qGTEBQ](https://www.youtube.com/watch?v=Iapc-qGTEBQ)

12. **Tracing - Log tracing platform** <br>
    [https://github.com/tokio-rs/tracing](https://github.com/tokio-rs/tracing)

13. **Actix Web** <br>
    Web Framework that's blazing fast, secure, asynchronous runs over Tokio and is "similar" to **Flask** of Python. <br>
    Can process **650.000 request per second**. <br>
    [https://actix.rs/](https://actix.rs/)

14. **Rocket** <br>
    Web Framework that's fast, secure and more "similar" to **Django** of Python. <br>
    [https://rocket.rs/](https://rocket.rs/)

15. **Serde** <br>
    Serde is a framework for **serializing** and **deserializing** Rust data structures efficiently and generically. <br>
    [https://serde.rs/](https://serde.rs/) <br>
    [https://crates.io/crates/serde](https://crates.io/crates/serde)

16. **BindGen** <br>
    Automatically generates Rust FFI bindings to C and C++ libraries. <br>
    [https://crates.io/crates/bindgen](https://crates.io/crates/bindgen) <br>
    Tutorial guide. <br>
    [https://rust-lang.github.io/rust-bindgen/](https://rust-lang.github.io/rust-bindgen/)

17. **Hacking rustc: Contributing to the Compiler by Esteban Kuber** - RustConf 2021 <br>
    [https://www.youtube.com/watch?v=9H9SO2u6Q20](https://www.youtube.com/watch?v=9H9SO2u6Q20)


## Rust Blogs

1. **pretzelhammer's Rust blog** <br>
   [https://github.com/pretzelhammer/rust-blog](https://github.com/pretzelhammer/rust-blog)

   1. **RESTful API in Sync & Async Rust - pretzelhammer** <br> 
      [https://github.com/pretzelhammer/rust-blog/blob/master/posts/restful-api-in-sync-and-async-rust.md](https://github.com/pretzelhammer/rust-blog/blob/master/posts/restful-api-in-sync-and-async-rust.md)

   2. **Common Rust Lifetime Misconceptions - pretzelhammer** <br>
      [https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md](https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md)

   3. **Tour of Rust's Standard Library Traits - pretzelhammer** <br>
      [https://github.com/pretzelhammer/rust-blog/blob/master/posts/tour-of-rusts-standard-library-traits.md](https://github.com/pretzelhammer/rust-blog/blob/master/posts/tour-of-rusts-standard-library-traits.md)

   4. **Sizedness in Rust – pretzelhammer** <br>
      [https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md](https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md)


## Machine Learning for Rust

1. **Taking ML to production with Rust: a 25x speedup** <br>
   [https://www.lpalmieri.com/posts/2019-12-01-taking-ml-to-production-with-rust-a-25x-speedup/](https://www.lpalmieri.com/posts/2019-12-01-taking-ml-to-production-with-rust-a-25x-speedup/)

2. **Machine learning in Rust using Linfa** <br>
   [https://blog.logrocket.com/machine-learning-in-rust-using-linfa/](https://blog.logrocket.com/machine-learning-in-rust-using-linfa/)

3. **Crate Linfa** <br>
   linfa aims to provide a comprehensive toolkit to build Machine Learning applications with Rust. <br>
   Kin **in spirit to Python's scikit-learn**, it focuses on common preprocessing tasks and classical ML algorithms for your everyday ML tasks. <br>
   [https://crates.io/crates/linfa](https://crates.io/crates/linfa) <br>
   [https://github.com/rust-ml/linfa](https://github.com/rust-ml/linfa)

4. **Crate tch-rs** <br>
   Rust wrappers for the **PyTorch C++ api** (libtorch). <br>
   [https://crates.io/crates/tch](https://crates.io/crates/tch) <br>
   [https://docs.rs/tch](https://docs.rs/tch)

5. **Crate Rust TensorFlow** <br>
   TensorFlow Rust provides idiomatic Rust language **bindings for TensorFlow**. <br>
   [https://crates.io/crates/tensorflow](https://crates.io/crates/tensorflow) <br>
   [https://github.com/tensorflow/rust](https://github.com/tensorflow/rust)

6. **Crate rust-xgboost** <br>
   Rust bindings for the **XGBoost gradient boosting library**. <br>
   [https://crates.io/crates/xgboost](https://crates.io/crates/xgboost)


## Rust Debugger

1. **How to Debug Rust with Visual Studio Code** <br>
   [https://www.forrestthewoods.com/blog/how-to-debug-rust-with-visual-studio-code/](https://www.forrestthewoods.com/blog/how-to-debug-rust-with-visual-studio-code/) 

2. **Debugging Rust with VS Code** <br>
   [https://dev.to/rogertorres/debugging-rust-with-vs-code-11dj](https://dev.to/rogertorres/debugging-rust-with-vs-code-11dj)

3. **CodeLLDB - Vadim Chugunov** <br>
   Plugin for VS Code <br>
   [https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb)


## Rust Error Handling

To define good error types that encapsulate other errors. In the case where you need to return from a function, multiple incompatible types, and you don't want to manually write conversion functions that implement the trait std::convert::From< > . <br>

1. Crate **Anyhow** <br>
   Use **Anyhow** if you don't care what error type your functions return, you just want it to be easy. This is common in application code. <br>
   [https://crates.io/crates/anyhow](https://crates.io/crates/anyhow)

2. Crate **thiserror** <br>
   Use **thiserror** if you are a library that wants to design your own dedicated error type(s) so that on failures the caller gets exactly the information that you choose. <br>
   [https://crates.io/crates/thiserror](https://crates.io/crates/thiserror)


## GC for Rust - Garbage Collector

“Cases where one needs to maintain a complicated, dynamic graph “(with cycles)” are where a GC becomes useful. Similarly, if one is writing an interpreter for a GCd language, having a GC in Rust would simplify things a lot.”

* **Designing a GC in Rust** <br>
  [https://manishearth.github.io/blog/2015/09/01/designing-a-gc-in-rust/](https://manishearth.github.io/blog/2015/09/01/designing-a-gc-in-rust/)

* **Crate rust-gc** <br>
  [https://crates.io/crates/gc](https://crates.io/crates/gc) <br>
  **Examples** <br>
  [https://github.com/Manishearth/rust-gc/tree/master/gc/tests](https://github.com/Manishearth/rust-gc/tree/master/gc/tests)


## Programming Parallel Computers - Optimization guide C++ and Rust

1. **Programming Parallel Computers - In depth lectures notes** <br>
   [https://ppc.cs.aalto.fi/](https://ppc.cs.aalto.fi/)

2. **Comparing Parallel Rust and C++** <br>
   [https://parallel-rust-cpp.github.io/](https://parallel-rust-cpp.github.io/)

3. **perf Examples** <br>
   See also the lecture. <br>
   [https://www.brendangregg.com/perf.html](https://www.brendangregg.com/perf.html)

4. **perf: Linux profiling with performance counters** <br>
   [https://perf.wiki.kernel.org/index.php/Main_Page](https://perf.wiki.kernel.org/index.php/Main_Page) 

5. **Systems Performance Enterprise and the Cloud 2nd Ed** <br>
	by Brendan Gregg

To **install Perf** on your Linux system you can do a simple package installation like apt-get if you are on a debian, then execute perf and it will tell you the package that you will have to install that is specific for your Linux kernel version. If your distribution automatically updates your kernel, you will need to download a new and correct version for your new kernel, and install it with your system package manager, ex: apt-get. <br> 
<br>
In the Rust .toml file add the 2 following lines, to add the debug symbols table to the Rust executable program file, compiled with ```--release``` flag: <br> 

```
[profile.release]
debug = true
```

To run **Perf profiling** on your Rust executable program. After that you can also use **flamegraph**. <br>

```
# Temporarily activate this flag perf_event_paranoid.

> echo -1 | sudo tee /proc/sys/kernel/perf_event_paranoid


# Record the executable program profiling data in a .data file.

> perf record -F99 --call-graph dwarf <path to the executable>


# To see the report use with Up/Down arrow keys, with "+"
# and with "a" to see the annotated assembly code with the Rust
# code correspondent code. The report will include the % of time in
# inside the function and in each group of assembly instructions.
# Press "tab" key in annotation mode to jump between hot spots.

> perf report
```

The **Perf profiler** has many command use the **stat** command to get the **IPC – Instruction Per Clock Cycle**, it's an average. <br>
<br>
To know **how much peak memory** your executable program uses do: <br>

```
> /usr/bin/time -v <path to the executable>
```

Note: There are 2 "time" executables and this is not the bash default time program. That's why you have to write the full path ```/usr/bin/time``` to execute it. <br>


6. **The Rust Performance Book** <br>
   [https://nnethercote.github.io/perf-book/title-page.html](https://nnethercote.github.io/perf-book/title-page.html)

7. **Guide to Optimization** <br>
   Achieving warp speed with Rust <br>
   [https://gist.github.com/jFransham/369a86eff00e5f280ed25121454acec1](https://gist.github.com/jFransham/369a86eff00e5f280ed25121454acec1) <br>
   Cheap tricks for high-performance Rust <br>
   [https://deterministic.space/high-performance-rust.html](https://deterministic.space/high-performance-rust.html)<br>
   Optimization - Making Rust Code Go Brrrr <br>
   [https://aspenuwu.me/blog/rust-optimization/](https://aspenuwu.me/blog/rust-optimization/) <br>
   Profile Guided Optimization <br>
   [https://doc.rust-lang.org/rustc/profile-guided-optimization.html](https://doc.rust-lang.org/rustc/profile-guided-optimization.html) <br>
   Optimizations: the speed size tradeoff <br>
   [https://rust-embedded.github.io/book/unsorted/speed-vs-size.html](https://rust-embedded.github.io/book/unsorted/speed-vs-size.html)


## Notes on optimization

* A **good example of applying optimization technics** to a high performance Rust program. <br>
  **Writing the Fastest GBDT Library in Rust by Isabella Tromba** - RustConf 2021 <br>
  [https://www.youtube.com/watch?v=D1NAREuicNs](https://www.youtube.com/watch?v=D1NAREuicNs)

* **Removal of bounds checks.** <br>
  Rust has **slice**, **array** and **Vec** bounds checks for each indices. <br>
  If you **use iterators** there will be **no bounds check**. <br>
  But in the common case Rust uses LLVM, and **LLVM** does a very good job at **removing the bounds checks that aren't needed**. <br>
  But if you need the fastest code implementation and want to **remove bounds check**, you can use ```get_unchecked()``` and ```get_unchecked_mut()```, they must be inside a **unsafe** block. <br>

``` Rust
let x = &mut [1, 2, 4];

unsafe {
    let elem = x.get_unchecked_mut(1);
    *elem = 13;
}
assert_eq!(x, &[1, 13, 4]);

```

* For the use case of **2D Vec** ```get_unchecked_mut()``` see the following code and benchmarks. <br>
  Performance of naive matrices in rust <br>
  [https://gist.github.com/TianyiShi2001/7f83854b91a94f3eaf3145084db6d627](https://gist.github.com/TianyiShi2001/7f83854b91a94f3eaf3145084db6d627)

``` Rust
// Normal performance: 84,694,933 ns/iter (+/- 7,412,836)

// This optimization:  41,440,947 ns/iter (+/- 752,463)   [x2 times faster]

fn bench_vec_of_vec_unsafe(b: &mut Bencher) {
    let (m, n) = (10000, 10000);
    let mut matrix = vec![vec![0u8; n]; m];
    b.iter(|| {
        for i in 0..m {
            for j in 0..n {
                unsafe {
                    *matrix.get_unchecked_mut(i).get_unchecked_mut(j) = 1u8;
                }
            }
        }
    });
}
```

* **ndarray - N dimensional array** <br>
  Crate ndarray <br>
  [https://crates.io/crates/ndarray](https://crates.io/crates/ndarray) <br>
  **Rust by example** - N Dimensional arrays <br>
  [https://rust-by-example-ext.com/ndarray.html](https://rust-by-example-ext.com/ndarray.html) <br>
  ndarray for numpy users <br>
  [https://docs.rs/ndarray/0.12.1/ndarray/doc/ndarray_for_numpy_users/index.html](https://docs.rs/ndarray/0.12.1/ndarray/doc/ndarray_for_numpy_users/index.html) <br>
  Rust Cookbook - **Linear Algebra** <br>
  [https://rust-lang-nursery.github.io/rust-cookbook/science/mathematics/linear_algebra.html](https://rust-lang-nursery.github.io/rust-cookbook/science/mathematics/linear_algebra.html) <br>
  Multidimensional Arrays and Operations with NDArray <br>
  [https://datacrayon.com/posts/programming/rust-notebooks/multidimensional-arrays-and-operations-with-ndarray/](https://datacrayon.com/posts/programming/rust-notebooks/multidimensional-arrays-and-operations-with-ndarray/) <br>
  ndarray-examples <br>
  [https://github.com/rust-ndarray/ndarray-examples](https://github.com/rust-ndarray/ndarray-examples) <br>
  For examples of usage, see ndarray project **github** in the **folders examples** and **tests** <br>
  [https://github.com/rust-ndarray/ndarray](https://github.com/rust-ndarray/ndarray)

* **smallvec** - **"Small vector"** optimization for Rust: store up to a small number of items **on the stack**. <br>
  [https://crates.io/crates/smallvec](https://crates.io/crates/smallvec)

* The HashMap in Rust uses strong cryptographic hashing for security reasons, but if the developer needs the fastest HashMap performance it can use an external faster and less secure hash function. <br>
**HashMap.with_hasher() info** <br>
[https://doc.rust-lang.org/beta/std/collections/struct.HashMap.html#method.with_hasher](https://doc.rust-lang.org/beta/std/collections/struct.HashMap.html#method.with_hasher) <br>
Insert crate **fasthash** into ```.toml``` file <br>

```Rust
use std::collections::HashMap;
use fasthash::murmur2::Murmur2_x86_64;

let s = Murmur2_x86_64::new();
let mut map = HashMap::with_hasher(s);
map.insert(1, 2);
```

* **But for a even faster HashMap or HashSet use**, <br>
  **hashbrown** - **Faster drop in replacement for STD HashMap and HashSet**, a Rust port of Google's high-performance SwissTable hash map. <br>
  [https://github.com/Amanieu/hashbrown](https://github.com/Amanieu/hashbrown) <br>
  Insert crate **hashbrown** into ```.toml``` file <br>

```Rust
// The fastest HashMap for Rust. HashBrown a drop in replacement for std HashMap.
use hashbrown::HashMap;
```

* **String continuations** <br>
  The backslash, the newline and the starting spaces will disappear. <br>

``` Rust
println!(
    "... the {p}, by the {p}, for the {p}, \
    will never fall.",
    p = "people"
);

Will print: 
"... the people, by the people, for the people, will never fall."
```

* For **ASCII Strings (value lower then 127) non UTF-8 strings**, one can process **much faster** the string if it is converted to bytes and then compared to bytes. <br>

``` Rust
let my_str = "Hello!".to_string();
for c in my_str.chars() {
    if c == 'l' {
        // Do something!
    }
}

// A faster implementation for ASCII characters would be.

let my_str_2 = "Hello!".to_string();
for b in my_str.bytes() {
    if b == b'l' {
        // Do something!
    }
}

// There is also a slice of bytes.

let my_str_3 = "Hello!".to_string();
let my_str_as_bytes_slice = my_str_3.as_bytes();

if my_str_as_bytes_slice[2] == b'l' {
        // Do something!
}
```

* **bstr** - A **fast string type** that is not required to be valid UTF-8. **No heavy UTF-8 validations.** <br>
  [https://crates.io/crates/bstr](https://crates.io/crates/bstr)

* **bumpalo - A fast bump heap allocation arena for Rust.** <br>
  [https://crates.io/crates/bumpalo](https://crates.io/crates/bumpalo)

* **How to use multiple variables in Rust's for loop?** <br>
  [https://stackoverflow.com/questions/43302808/how-to-use-multiple-variables-in-rusts-for-loop](https://stackoverflow.com/questions/43302808/how-to-use-multiple-variables-in-rusts-for-loop)

* **The ASM! macro to insert inline Assembly** <br>
  New inline assembly syntax <br>
  [https://blog.rust-lang.org/inside-rust/2020/06/08/new-inline-asm.html](https://blog.rust-lang.org/inside-rust/2020/06/08/new-inline-asm.html) <br>
  ASM! at the Unstable Book <br>
  [https://doc.rust-lang.org/beta/unstable-book/library-features/asm.html](https://doc.rust-lang.org/beta/unstable-book/library-features/asm.html)


## Rust substring processing

* Rust string processing is kind of hard, because text in a UTF-8 world has many complex details, and Rust exposes all that power and all that complexity to you, the programmer. Sometimes it can be over whelming. Sometimes you only want to have a simple substring or a slice and you don’t mind to pay it’s cost, because you really need this feature and the Standard Library doesn’t help you a lot there.

* Fortunately **carlomilanesi** made this code available to all <br>
[https://users.rust-lang.org/t/how-to-get-a-substring-of-a-string/1351/11](https://users.rust-lang.org/t/how-to-get-a-substring-of-a-string/1351/11)

* But if you have to do many text operations based on the positions of chars inside a strings this isn’t a really good option, because you have to scan all the strings to the correct position, from the start, to have the string divided it into the correct boundaries of the chars. In this context, you would happily pay a up front cost of transforming the string into a Vec<char>, Vec of chars with individual chars separated, and process it as positional chars with access cost of 1 and then, slice them, range them, append to them at the end (or if you need to append in the start or the middle paying the cost of copy to a new buffer, but you can do it if you need to). **The following code is my expansion** to the code of **carlomilanesi**. It will allow you to do it. <br>
You can find it also in my GitHub repository in… <br>

* **SubStrings, Slices and Random String Access in Rust** <br>
  [https://github.com/joaocarvalhoopen/SubStrings_Slices_and_Random_String_Access_in_Rust](https://github.com/joaocarvalhoopen/SubStrings_Slices_and_Random_String_Access_in_Rust) <br>
<br>


``` Rust
use std::ops::{Bound, RangeBounds};

trait StringUtils {
    fn substring(&self, start: usize, len: usize) -> &str;
    fn slice(&self, range: impl RangeBounds<usize>) -> &str;
    fn get_vec_chars(&self) -> Vec<char>;
}

impl StringUtils for str {
    fn substring(&self, start: usize, len: usize) -> &str {
        let mut char_pos = 0;
        let mut byte_start = 0;
        let mut it = self.chars();
        loop {
            if char_pos == start { break; }
            if let Some(c) = it.next() {
                char_pos += 1;
                byte_start += c.len_utf8();
            }
            else { break; }
        }
        char_pos = 0;
        let mut byte_end = byte_start;
        loop {
            if char_pos == len { break; }
            if let Some(c) = it.next() {
                char_pos += 1;
                byte_end += c.len_utf8();
            }
            else { break; }
        }
        &self[byte_start..byte_end]
    }
    fn slice(&self, range: impl RangeBounds<usize>) -> &str {
        let start = match range.start_bound() {
            Bound::Included(bound) | Bound::Excluded(bound) => *bound,
            Bound::Unbounded => 0,
        };
        let len = match range.end_bound() {
            Bound::Included(bound) => *bound + 1,
            Bound::Excluded(bound) => *bound,
            Bound::Unbounded => self.len(),
        } - start;
        self.substring(start, len)
    }
    fn get_vec_chars(&self) -> Vec<char> { self.chars().collect() }
}

trait StringUtilsVecChars {
    fn to_string(&self) -> String;
    fn to_string_buf<'a>(&self, buf: & 'a mut String) -> & 'a String;
}

impl StringUtilsVecChars for Vec<char> {
    fn to_string(&self) -> String { self.iter().collect() }
    fn to_string_buf<'a>(&self, buf: & 'a mut String) -> & 'a String {
        buf.clear();
        for c in self.iter() { buf.push(*c); }
        buf
    }
}

trait StringUtilsSlices {
    fn to_string(&self) -> String;
    fn to_string_buf<'a>(&self, buf: & 'a mut String) -> & 'a String;
}

impl StringUtilsSlices for [char] {
    fn to_string(&self) -> String { self.iter().collect() }
    fn to_string_buf<'a>(&self, buf: & 'a mut String) -> & 'a String {
        buf.clear();
        for c in self.iter() { buf.push(*c); }
        buf
    }
}

fn main() {
    let s = "abcdèfghij";
    // All three statements should print:
    // "abcdè, abcdèfghij, dèfgh, dèfghij."
    println!("{}, {}, {}, {}.",
        s.substring(0, 5),
        s.substring(0, 50),
        s.substring(3, 5),
        s.substring(3, 50));
    println!("{}, {}, {}, {}.",
        s.slice(..5),
        s.slice(..50),
        s.slice(3..8),
        s.slice(3..));
    println!("{}, {}, {}, {}.",
        s.slice(..=4),
        s.slice(..=49),
        s.slice(3..=7),
        s.slice(3..));

    // Allocating a string from Vec<char>.
    let mut vc = s.get_vec_chars(); 
    println!("{}, {}, {}, {}.",
        vc[..5].to_string(),
        vc.to_string(),
        vc[3..8].to_string(),
        vc[3..].to_string());

    // Reusing a String buffer from a Vec<char>.
    let mut buf = String::new();
    print!("{}, ", vc[..5].to_string_buf(& mut buf));
    print!("{}, ", vc[..].to_string_buf(& mut buf));
    print!("{}, ", vc[3..8].to_string_buf(& mut buf));
    print!("{}.\n", vc[3..].to_string_buf(& mut buf));
    
    // Random access to the Vec<char>. 
    for i in 0..(vc.len() - 2) {
        print!("{} ", vc[i..i+3].to_string_buf(& mut buf));
    }
    println!("");
    
    // Random modifications to the Vec<char>.
    for i in (0..(vc.len() / 3) + 1).rev() {
        vc.insert(i*3, '#');
    }
    println!("{} ", vc.to_string());
    println!("{} ", vc.to_string_buf(& mut buf));
}

// Output:
//    abcdè, abcdèfghij, dèfgh, dèfghij.
//    abcdè, abcdèfghij, dèfgh, dèfghij.
//    abcdè, abcdèfghij, dèfgh, dèfghij.
//
//    abcdè, abcdèfghij, dèfgh, dèfghij.
//    abcdè, abcdèfghij, dèfgh, dèfghij.
//    abc bcd cdè dèf èfg fgh ghi hij 
//    #abc#dèf#ghi#j
//    #abc#dèf#ghi#j
```

## Good way to learn about the topic of computers and programming

1. **Video - Computer Science - Crash Course** <br> 
   [https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo](https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo)

## For a good challenge do the NAND To Tetris in Rust

1. **From Nand to Tetris** <br>
   Building a Modern Computer From First Principles <br>
   [https://www.nand2tetris.org/](https://www.nand2tetris.org/)

2. **Video - Shimon Schocken: The self-organizing computer course** <br>
   [https://www.youtube.com/watch?v=iE7YRHxwoDs](https://www.youtube.com/watch?v=iE7YRHxwoDs)

3. **Video - From Nand to Tetris Part I Course Promo** <br>
   [https://www.youtube.com/watch?v=wTl5wRDT0CU](https://www.youtube.com/watch?v=wTl5wRDT0CU)

4. **Free Course - Build a Modern Computer from First Principles** <br>
   From Nand to Tetris (Project-Centered Course) <br>
   [https://www.coursera.org/learn/build-a-computer](https://www.coursera.org/learn/build-a-computer)

5. **Free Course - Build a Modern Computer from First Principles** <br>
   Nand to Tetris Part II (project-centered course) <br>
   [https://www.coursera.org/learn/nand2tetris2](https://www.coursera.org/learn/nand2tetris2)


# All my other guides

* The links to all my guides are in: <br>
  **Guides on Linux - Programming - Embedded - Electronics - Aeronautics** <br>
  [https://github.com/joaocarvalhoopen/Guides_Linux-Programming-Electronics-Aeronautics](https://github.com/joaocarvalhoopen/Guides_Linux-Programming-Electronics-Aeronautics)


# Have fun!
Best regards, <br>
Joao Nuno Carvalho <br>


